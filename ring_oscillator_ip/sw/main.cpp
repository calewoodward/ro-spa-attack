// Copyright (c) 2020 University of Florida
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Greg Stitt
// University of Florida
//
// Description: This application demonstrates a simple AFU pipeline that 
// streams 32-bit unsigned integers from an input array into the AFU. The AFU 
// multiplies 8 pairs of inputs (from a single cache line), accumulates the 
// results, and writes a 64-bit result to an output array. Because a full 
// cache line must be written to memory with the provided DMA, the application 
// takes as input the number of output cache lines, and then determines the 
// appropriate number of outputs and inputs to fill those cache lines. 
//
// This software allocates the input and output arrays, initializes their 
// contents, transfers the virtual addresses of the arrays, the 
// number of input cache lines to read, and a go signal to start the AFU. The
// software then waits until the AFU signals that it is done.

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <cmath>
#include <chrono>
#include <opae/utils.h>
#include <string>
#include "AFU.h"
// Contains application-specific information
#include "config.h"
// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"

using namespace std;

void printUsage(char *name);
bool checkUsage(int argc, char *argv[], unsigned long &num_output_cls, unsigned long &num_cycles);

int main(int argc, char *argv[]) {

  unsigned long num_output_cls;
  unsigned long num_collect_cycles;
  unsigned long num_inputs;
  unsigned long num_outputs;

  if (!checkUsage(argc, argv, num_output_cls, num_collect_cycles)) {
    printUsage(argv[0]);
    return EXIT_FAILURE;
  }
  
  // There are 16 32-bit outputs per cache line.
  num_outputs = num_output_cls * 16;
  // There are 16 32-bit inputs per output.
  num_inputs = 10;

  try {
    AFU afu(AFU_ACCEL_UUID); 
    bool failed = false;
    //afu.reset();

    // Allocate input and output arrays.
    auto input  = afu.malloc<volatile uint32_t>(num_inputs);
    auto output = afu.malloc<volatile uint32_t>(num_outputs);  

    // allocate the variables for timestamps
    chrono::high_resolution_clock::time_point    roStart;
    chrono::high_resolution_clock::time_point    rsaStart;
    //chrono::duration<chrono::microseconds>       tplus_rsaStart;
    chrono::high_resolution_clock::time_point    rsaStop;
    //chrono::duration<chrono::microseconds>       tplus_rsaStop;
    chrono::high_resolution_clock::time_point    roStop;
    //chrono::duration<chrono::microseconds>       tplus_roStop;

    // Initialize the input and output arrays.
    for (unsigned i=0; i < num_inputs; i++) {      
      input[i] = rand();
    }

    // initialize the output array with all 0
    for (unsigned i=0; i < num_outputs; i++) {      
      output[i] = 0;
    }   
    
    // write location of the output array to the MMIO
    afu.write(MMIO_RD_ADDR, (uint64_t) input);
    afu.write(MMIO_WR_ADDR, (uint64_t) output);

    // write the number of samples requested to MMIO
    afu.write(MMIO_NUM_SAMPLES, num_outputs);
    afu.write(MMIO_COLLECT_CYCLES, num_collect_cycles);

    cout  << "Starting RO...\n";
    roStart = std::chrono::high_resolution_clock::now();
    // send the go signal for the FPGA to begin collection RO measurements
    afu.write(MMIO_GO, 1);  

    // wait a bit before triggering the power draw
    //this_thread::sleep_for(chrono::milliseconds(5));
    
    rsaStart = std::chrono::high_resolution_clock::now();
    // send the ho signal for RSA to begin decryption
    afu.write(MMIO_RSA_GO, 1);  
    
    bool rsaDoneFlag = false;
    // wait until FPGA has collected the requested number of samples
    while (afu.read(MMIO_DONE) == 0) {
      if (afu.read(MMIO_RSA_DONE) == 1) {
        rsaStop = std::chrono::high_resolution_clock::now();
	rsaDoneFlag = true;
    	while (afu.read(MMIO_DONE) == 0); 
      }
    }
    
    roStop = std::chrono::high_resolution_clock::now();
  
    auto tplus_rsaStart = std::chrono::duration_cast<std::chrono::microseconds>(rsaStart - roStart);

    cout << "RO  started at T+ 0 us" <<  endl
	 << "RSA started at T+ " << tplus_rsaStart.count() << " us" << endl;
    
    // check if the RSA module finished during RO collection cycles
    if (rsaDoneFlag) {
        auto tplus_rsaStop = std::chrono::duration_cast<std::chrono::microseconds>(rsaStop - roStart);
        cout << "RSA stopped at T+ " << tplus_rsaStop.count() << " us" << endl;
    }
    else {
	    cout << "WARNING: RO stopped before RSA was finished" << endl;
    }
   
    auto tplus_roStop = std::chrono::duration_cast<std::chrono::microseconds>(roStop - roStart);
    cout << "RO  stopped at T+ " << tplus_roStop.count() << " us" << endl;
        
    string file_name = "/home/u208080/ro_rsa.txt";
    cout << "Writing outputs to file: " << file_name << endl;
    ofstream txt_out(file_name.c_str());
    for (unsigned i=0; i < num_outputs; i++) { 
      txt_out << output[i] << endl;
    }
    txt_out.close();

    // Free the allocated memory.
    afu.free(input);
    afu.free(output);

    cout << "Exiting..." << endl;

  }

  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}


void printUsage(char *name) {

  cout << "Usage: " << name << " size hold_cycles\n"     
       << "size (positive integer for number of RO collection cache lines. Every cache line adds 16 32-bit outputs.)\n"
       << "hold_cycles (positive integer for number of FPGA clock cycles to let the ring oscillator run before transferring a line of data)\n"
       << endl;
}

// Returns unsigned long representation of string str.
// Throws an exception if str is not a positive integer.
unsigned long stringToPositiveInt(char *str) {

  char *p;
  long num = strtol(str, &p, 10);  
  if (p != 0 && *p == '\0' && num > 0) {
    return num;
  }

  throw runtime_error("String is not a positive integer.");
  return 0;  
}


bool checkUsage(int argc, char *argv[], unsigned long &num_output_cls, unsigned long &num_cycles) {
  
  if (argc == 3) {
    try {
      num_output_cls = stringToPositiveInt(argv[1]);
      num_cycles     = stringToPositiveInt(argv[2]);
    }
    catch (const runtime_error& e) {    
      return false;
    }
  }
  else {
    return false;
  }

  return true;
}
